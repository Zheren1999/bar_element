import numpy as np
import matplotlib.pyplot as plt
import math
import bisect
from scipy.interpolate import interp1d


mcr=2
k1=16*(math.pi)**4

k3=0.1*k1
s=2*k3/(k1+(math.pi)**4*mcr**4)


y=1.5
x1=np.array([0.01, 0.01,0.01,0.01,0.01])


def KroneckerDelta (j,k):
    d=0
    if j==k:
        d=1;
    else:
        d=0
    return d



def am(m):
    return (((m**2*(math.pi)**2+(k1/(m**2*(math.pi)**2)) ))/ (((math.pi)**2*mcr**2)+(k1/((math.pi)**2*mcr**2))))


def F(x):
    
    Im=np.array([3*((y)**3 - x[1]*y**2 + 2*((x[0])**2-x[2]*x[0]+(x[1])**2+(x[2])**2)*y+x[0]*x[1]*(x[0]+2*x[2])),
             3*((x[0])**3+2*((x[1])**2+(x[2])**2)*x[0]+y**2*(2*x[0]-x[2])+(x[1])**2*x[2]+2*y*x[1]*(x[0]+x[2])),
             -y**3+6*x[1]*y**2+3*x[0]*(x[0]+2*x[2])*y+3*x[1]*(2*(x[0])**2+2*x[2]*x[0]+(x[1])**2+2*(x[2])**2),
             3*((x[2])**3+2*(x[0])**2*x[2]+2*(x[1])**2*x[2]+x[0]*(x[1])**2+2*y*x[0]*x[1]-y**2*(x[0]-2*x[2]))])

   
        
    dd=np.array([ (x[0]+x1[1])*(am(1)*y-s*mcr**2*Im[0]/8)-(y+x1[0])*(am(2)*x[0]-s*mcr**2*Im[1]/(8*2**2)),
          (x[1]+x1[2])*(am(2)*x[0]-s*mcr**2*Im[1]/(8*2**2))-(x[0]+x1[1])*(am(3)*x[1]-s*mcr**2*Im[2]/(8*3**2)),
          (x[2]+x1[3])*(am(3)*x[1]-s*mcr**2*Im[2]/(8*3**2))-(x[1]+x1[2])*(am(4)*x[2]-s*mcr**2*Im[3]/(8*4**2))])
    return dd

def J(x):
    
    Im=np.array([3*((y)**3 - x[1]*y**2 + 2*((x[0])**2-x[2]*x[0]+(x[1])**2+(x[2])**2)*y+x[0]*x[1]*(x[0]+2*x[2])),
             3*((x[0])**3+2*((x[1])**2+(x[2])**2)*x[0]+y**2*(2*x[0]-x[2])+(x[1])**2*x[2]+2*y*x[1]*(x[0]+x[2])),
             -y**3+6*x[1]*y**2+3*x[0]*(x[0]+2*x[2])*y+3*x[1]*(2*(x[0])**2+2*x[2]*x[0]+(x[1])**2+2*(x[2])**2),
             3*((x[2])**3+2*(x[0])**2*x[2]+2*(x[1])**2*x[2]+x[0]*(x[1])**2+2*y*x[0]*x[1]-y**2*(x[0]-2*x[2]))])

    ddd= np.array(
                 [[(am(1)*y-s*mcr**2*Im[0]/8)+(x[0]+x1[1])*(-s*mcr**2*(3*(4*x[0]*y-2*x[2]*y+2*x[1]*x[0]+2*x[2]*x[1])/8))-
                   (y+x1[0])*(am(2)-s*mcr**2*(3*(3*(x[0])**2+2*((x[1])**2+(x[2])**2)+2*y**2+2*y*x[1])/8*2**2)),
                   
                   (-s*mcr**2*(3*(-y**2+4*x[1]*y)+x[0]*(x[0]+2*x[2])/8))*(x[0]+x1[1])-
                   (y+x1[0])*(-s*mcr**2*(3*(4*x[1]*x[0]+2*x[1]*x[2]+2*y*(x[0]+x[2]))/8*2**2)),
                   
                   (-s*mcr**2*(3*(-2*x[0]*y+4*x[2]*y+2*x[0]*x[1])/8))*(x[0]+x1[1])-
                    (y+x1[0])*(-s*mcr**2*(3*(4*x[2]*x[0]-y**2+2*y*x[1]+(x[1])**2)/8*2**2))],


                  
                  [(am(2)-s*mcr**2*(3*(3*(x[0])**2+2*((x[1])**2+(x[2])**2)+2*y**2+2*y*x[1])/(8*2**2)))*(x[1]+x1[2])-
                   (am(3)*x[1]-s*mcr**2*Im[2]/(8*3**2))-(x[0]+x1[1])*(-s*mcr**2*(6*x[0]*y+6*x[2]*y+12*x[1]*x[0]+6*x[1]*x[2])/(8*3**2)),
                   
                   (am(2)*x[0]-s*mcr**2*Im[1]/(8*2**2))+(x[1]+x1[2])*(-s*mcr**2*(3*(4*x[1]*x[0]+2*x[1]*x[2]+2*y*(x[0]+x[2]))/(8*2**2)))-
                   (x[0]+x1[1])*(am(3)-(s*mcr**2*(6*y**2+6*(x[0])**2+6*x[2]*x[0]+9*(x[1])**2+6*(x[2])**2)/(8*3**2))),
                   
                   (-s*mcr**2*((3*(4*x[2]*x[0]-y**2+2*y*x[1]+(x[1])**2))/(8*2**2)))*(x[1]+x1[2])-
                    (x[0]+x1[1])*(-s*mcr**2*(6*x[0]*y+6*x[1]*x[0]+12*x[1]*x[2])/(8*3**2))],



                  
                  [(-s*mcr**2*(((6*x[0]*y+6*x[2]*y+12*x[1]*x[0]+6*x[1]*x[2]))/(8*3**2)))*(x[2]+x1[3])-
                   (x[1]+x1[2])*(-s*mcr**2*(3*(4*x[0]*x[2]+(x[1])**2+2*y*x[1]-y**2))/(8*4**2)),
                   
                   (am(3)-s*mcr**2*((6*y**2+6*(x[0])**2+6*x[2]*x[0]+9*(x[1])**2+6*(x[2])**2)/(8*3**2)))*(x[2]+x1[3])-
                   (am(4)*x[2]-s*mcr**2*Im[3]/(8*4**2))-(x[2]+x1[3])*(-s*mcr**2*3*(4*x[1]*x[2]+2*x[0]*x[1]+2*y*x[0])/(8*4**2)),
                  
                   (am(3)*x[1]-(s*mcr**2*Im[2]/(8*3**2)))+(x[2]+x1[3])*(-s*mcr**2*(6*x[0]*y+6*x[1]*x[0]+12*x[1]*x[2])/(8*3**2))-
                   (x[1]+x1[2])*(am(4)-s*mcr**2*((3*(3*(x[2])**2+2*(x[0])**2+2*(x[1])**2+2*y**2))/(8*4**2)))]
                   ])
    return ddd

def Newton_method(F, J, x, eps):
    F_value = F(x)
    F_norm = np.linalg.norm(F_value,ord=2)
    iteration_counter = 0
    while abs(F_norm) > eps and iteration_counter < 100:
        
        delta = np.linalg.solve(J(x),-F_value)
        x = x + delta
       
        F_value = F(x)
        F_norm = np.linalg.norm(F_value,ord=2)
        iteration_counter += 1

    if abs(F_norm) > eps:
        iteration_counter = -1
    return x, iteration_counter




p, n = Newton_method(F, J, x=np.array([0.1,0.1,0.1]), eps=0.00000000001)
print ('p', p)

Imm=np.array([3*((y)**3 - p[1]*y**2 + 2*((p[0])**2-p[2]*p[0]+(p[1])**2+(p[2])**2)*y+p[0]*p[1]*(p[0]+2*p[2])),
             3*((p[0])**3+2*((p[1])**2+(p[2])**2)*p[0]+y**2*(2*p[0]-p[2])+(p[1])**2*p[2]+2*y*p[1]*(p[0]+p[2])),
             -y**3+6*p[1]*y**2+3*p[0]*(p[0]+2*p[2])*y+3*p[1]*(2*(p[0])**2+2*p[2]*p[0]+(p[1])**2+2*(p[2])**2),
             3*((p[2])**3+2*(p[0])**2*p[2]+2*(p[1])**2*p[2]+p[0]*(p[1])**2+2*y*p[0]*p[1]-y**2*(p[0]-2*p[2]))])

alpha=np.array([(am(1)*y-s*mcr**2*Imm[0]/8)/(y+x1[0]),
                 (am(2)*p[0]-s*mcr**2*Imm[1]/(8*2**2))/(p[0]+x1[1]),
                 (am(3)*p[1]-s*mcr**2*Imm[2]/(8*3**2))/(p[1]+x1[2]),
                (am(4)*p[2]-s*mcr**2*Imm[3]/(8*4**2))/(p[2]+x1[3])])
print('Imm', Imm[0])
x_new=np.array([y,p[0],p[1], p[2]])
print ('x_new', x_new)
print ('alpha', alpha[0])
#plt.plot(x_new,alpha)
#f = interp1d(-x, alpha)
#xnew = np.linspace(0, 29.12585937,100)

#plt.plot(xnew, f(xnew))

#plt.show()

